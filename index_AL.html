
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Fractal Land Simulation 0.1</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #000; /*#61443e*/
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #000; /*#aaccff*/
				margin: 0px;
				overflow: hidden;
			}

			#info {
				color: #ffffff;
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}
			
			#jhStats {
				position: absolute;
				top: 0px;
				width: 100%;
				padding: 5px;
				color: #F00;
			}

			a {

				color: yellow;
			}

			#oldie {
				background:rgb(0,0,50) !important;
				color:#fff !important;
			}

		</style>
	</head>
	<body>

		<div id="container"></div>
		<div id="jhStats"></div>
		<!--<div id="info"><a href="http://threejs.org" target="_blank">three.js</a> - dynamic geometry demo - webgl<br />(left click: forward, right click: backward)</div>-->

		<script src="./three.min.js"></script>
		<script type="text/javascript" src="./fracutils.js"></script>

		<script src="./FirstPersonControls.js"></script>

		<script src="./Detector.js"></script>
		
		<script src="//ajax.googleapis.com/ajax/libs/dojo/1.10.1/dojo/dojo.js" data-dojo-config="async: true"></script>

		<!-- script src="./stats.min.js"></script -->

		<script>
			require(['dojo/_base/array'], function(array) {

				if ( ! Detector.webgl ) {
	
					Detector.addGetWebGLMessage();
					document.getElementById( 'container' ).innerHTML = "";
	
				}
	
				/*******************************************
				 * IDEAS
				 * 
				 * A) Create and maintain a separate array of info re: each pixel; draw from that array
				 *    to populate/update the actual terrain.  Info to record per pixel:
				 *    i)   center X in fractal space
				 *    ii)  center Y in fractal space
				 *    iii) iters (pre-erosion)
				 *    iv)  height (post-erosion)
				 *    
				 * B) Telescopic view = 2nd camera with narrow/deep field
				 */
	
				var container, stats;
	
				var camera, controls, scene, renderer;
	
				var mesh, texture, geometry, material;
				
				var mag, fcX, fcY, maxIter; // magnification factor, fractal center X, fractal center Y
	
				// TEST COORDS 01
				fcX = -0.0438;
				fcY = 0.9867; // 0.9867
				mag = 54;
				maxIter = 500;
					
				// specify resolution of the world
				var worldWidth = 256, worldDepth = 256,
				worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;
				
				// How many world units equals one (unmagnified) unit fractal space?
				var scaleFactor = 2500;
				
				var cameraHoverHeight = 50;
				var timesToGrowLandscape = 0;
	
				var clock = new THREE.Clock();

				var fracUtils = createFracUtils();
				var fracArray = createFracArray((worldWidth-1)*3); // guarantees there's a "middle"	
	
				fracArray = initFracArray(fracArray, fcX, fcY, mag, maxIter, worldWidth);
				
				init();
			   animate();
	
				function createFracArray(rows) {
					var arr = [];
					for (var i = 0; i < rows; i++) {
						arr[i] = [];
					}
					return arr;					
				}
				
				function initFracArray(fa, fracCtrX, fracCtrY, fracMag, fracMaxIter, fracRez) {
					// determine the size of the array
					var faLength = fa.length;
					var faHalfLength = faLength / 2;
					
					// determine the increment (distance) between pixels based on mag and resolution
					// (assume that at 1x, min/max are all 1.0 out on their respective axes)
					var radius = 1 / fracMag;
					var incr = radius / (fracRez / 2);
					
					//alert("incr: " + incr);
					
					// loop through and populate each position in fracArray with an array containing pieces of info:
					var pixelX; 		//  [0] center X of "pixel" in fractal space
				 	var pixelY; 		//  [1] center Y of "pixel" in fractal space
				 	var valRaw; 		//  [2] raw calc'd iter value
				 	var valProcessed; //  [3] stretched and eroded iter value
					for (var y = 0; y < faLength; y ++) {
						for (var x = 0; x < faLength; x ++) {
							fa[x][y] = [];
							pixelX = fracCtrX + (incr * (x - faHalfLength)); 
							pixelY = fracCtrY + (incr * (y - faHalfLength)); 
							valRaw = calcRawIter2(pixelX,pixelY);
							valProcessed = (Math.log(Math.log(Math.log(valRaw))) * 1000) - 500;
							fa[x][y] = [pixelX, pixelY, valRaw, valProcessed];
						}
					}
					
					// alert("faHalfLength: " + faHalfLength + "\n" + 
					// 		"x,y,raw of 90,100: " + fa[90][100][0] + "," + fa[90][100][1] + "," + fa[90][100][2] + "\n" +
					// 		"x,y,raw of 100,100: " + fa[100][100][0] + "," + fa[100][100][1] + "," + fa[100][100][2] + "\n" +
					// 		"x,y,raw of 110,100: " + fa[110][100][0] + "," + fa[110][100][1] + "," + fa[110][100][2]);
					//alert("x,y,raw of center: " + fa[faHalfLength-1][faHalfLength-1][0] + "," + fa[faHalfLength-1][faHalfLength-1][1] + "," + fa[faHalfLength-1][faHalfLength-1][2]);
					
					// erode the stretched iter values
					var erosion = [];
					var hnN, hnW, hnE, hnS;
					for (var z = 0; z < 7; z++) { // apply erosion this many times
						for (y = 0; y < faLength; y++) {
							for (x = 0; x < faLength; x++) {
								if (y==0) {hnN = null} else {hnN = fa[y-1][x][3]}
								if (y==faLength-1) {hnS = null} else {hnS = fa[y+1][x][3]}
								if (x==0) {hnW = null} else {hnW = fa[y][x-1][3]}
								if (x==faLength-1) {hnE = null} else {hnE = fa[y][x+1][3]}
								erosion = fracUtils.erodeHeight2(y, x, fa[y][x][3], hnN, hnW, hnE, hnS, faLength); 
								fa[y][x][3] = erosion[0];
								fa[erosion[1]][erosion[2]][3] += erosion[3];
							}
						}
					}
					
					return fa;
					
				}

				function init() {
					container = document.getElementById( 'container' );
	
					scene = new THREE.Scene();
					//scene.fog = new THREE.FogExp2( 0x000000, 0.0007 );
	
					// LIGHT
					// var light = new THREE.HemisphereLight(0xffffff,0xffffff,1);
					// light.position.set(-1300,100,-1300);
					// scene.add(light);
	
					// CAMERA
					camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 20000 );
					camera.position.set(-1500,100,-1500);
					camera.up = new THREE.Vector3(0,1,0);
	
					// ACTION :-)
					controls = new THREE.FirstPersonControls( camera );
					controls.movementSpeed = 300;
					controls.lookSpeed = 0.3;
	
					geometry = new THREE.PlaneGeometry( 4096, 4096, worldWidth - 1, worldDepth - 1 );
					geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );
					geometry.dynamic = true;
	
					var i, j, il, jl;

					// alert("v0: x=" + geometry.vertices[10].x + "\n" +
					//       "    y=" + geometry.vertices[10].y + "\n" + 
					//       "    z=" + geometry.vertices[10].z);
	
					var iX = 0, iY = 0;
					for ( var i = 0, l = geometry.vertices.length; i < l; i ++ ) {
					   geometry.vertices[i].y = fracArray[iX][iY][3];

					   // get the appropriate value from the appropriate location in the fracArray
					   iX++;
					   if (iX==worldWidth) {
					   	iX = 0;
					   	iY++;
					   }
					}

					//console.log( "triangles: " + geometry.faces.length * 2 + " faces: " + geometry.faces.length + " vertices: " + geometry.vertices.length );
	
					geometry.computeFaceNormals();
					geometry.computeVertexNormals();
	
					var vertexColorMaterial  = new THREE.MeshBasicMaterial( { vertexColors: THREE.VertexColors } );
	
					//color the vertices
					geometry = fracUtils.calcVertexColors(geometry);
					
					mesh = new THREE.Mesh( geometry, vertexColorMaterial );
					//scene.add( mesh ); // unnecc -- why?
	
					// "wireframe texture"
					var wireTexture = new THREE.ImageUtils.loadTexture( './square.png' );
					wireTexture.wrapS = wireTexture.wrapT = THREE.RepeatWrapping; 
					wireTexture.repeat.set( 40, 40 );
	
					var wireMaterial = new THREE.MeshBasicMaterial( { map: wireTexture, vertexColors: THREE.VertexColors } );
					wireMaterial.map.repeat.set( worldWidth, worldDepth );
	
					var graphMesh = new THREE.Mesh( geometry, wireMaterial );
					graphMesh.doubleSided = true;
					scene.add(graphMesh);
	
	
					renderer = new THREE.WebGLRenderer();
					renderer.setClearColor( 0x000000, 1 ); // 0xaaccff
					renderer.setSize( window.innerWidth, window.innerHeight );
	
					container.innerHTML = "";
	
					container.appendChild( renderer.domElement );
	
				// 	stats = new Stats();
				// 	stats.domElement.style.position = 'absolute';
				// 	stats.domElement.style.top = '0px';
				// 	container.appendChild( stats.domElement );
	
					window.addEventListener( 'resize', onWindowResize, false );
	
				}
	
				function render() {
	
					var delta = clock.getDelta(),
						time = clock.getElapsedTime() * 10;
					
					var needToUpdate = false;
					
					//var middleVertexIndex = geometry.vertices.length/2;
					
					var jhStats = document.getElementById("jhStats");
					jhStats.innerHTML = "(X,Z,Y): " + camera.position.x + "," + camera.position.z + "," + camera.position.y;
					
					// if (Math.abs(camera.position.x - geometry.vertices[middleVertexIndex].x) > 3000 ||
					// 	 Math.abs(camera.position.z - geometry.vertices[middleVertexIndex].z) > 3000) {
						//
						// modify the vertices in some fashion here
						// 
						// var centerX = geometry.vertices[middleVertexIndex].x;
						// var centerZ = geometry.vertices[middleVertexIndex].z;
						// for ( var i = 0, l = geometry.vertices.length; i < l; i ++ ) {
						// 	// move each vertex 0.1% further from the center
						// 	deltaX = geometry.vertices[i].x - centerX;
						// 	deltaZ = geometry.vertices[i].z - centerZ;
						// 	geometry.vertices[i].x += (deltaX*0.001);
						// 	geometry.vertices[i].z += (deltaZ*0.001);
							
						// }
						
					// 	mesh.geometry.verticesNeedUpdate = true;
					// }
					
					var landscapeNeedsUpdate = false;
					
					// reposition the player
					// if (Math.abs(camera.position.x) > 25 || Math.abs(camera.position.z) > 25) {
					// 	resetPosition();
					// 	timesToGrowLandscape += 50;
					// 	landscapeNeedsUpdate = false;
					// }
					
					// shift the landscape
					if (Math.abs(camera.position.x) >= worldWidth) {
						shiftAlongAxis('X');
					}
					if (Math.abs(camera.position.z) >= worldDepth) {
						shiftAlongAxis('Z');
					}
	
					
					// grow landscape if needed
					if (timesToGrowLandscape > 0) {
						growLandscape();
						timesToGrowLandscape--;
					}
					
					// Update the landscape
					if (landscapeNeedsUpdate) {
						var worldY;
						for ( var i = 0, l = geometry.vertices.length; i < l; i ++ ) {
		
							//geometry.vertices[ i ].y = 135 * Math.sin( i / 5 + ( time + i ) / 7 );
						   //geometry.vertices[i].y = (i-8192)/8;
						   worldY = calcRawIter(geometry.vertices[i].x,geometry.vertices[i].z);
						   worldY = (Math.log(Math.log(worldY)) * 500) - 500;
						   geometry.vertices[i].y = worldY;
						}
						
						for (var z = 0; z < 2; z++) {
							erodeLandscape();
						}
			
						//geometry.computeFaceNormals();
						//geometry.computeVertexNormals();
		
						mesh.geometry.verticesNeedUpdate = true;
						//mesh.geometry.normalsNeedUpdate = true;
					} else {
						geometry = geometry;
					}
	
					// update the elevation of the camera
					var eVector = new THREE.Vector3(0,-1,0);
					var eRayCaster = new THREE.Raycaster(camera.position, eVector);
					var intersects = eRayCaster.intersectObject(mesh);
					if (intersects.length > 0) {
						if (intersects[0].distance > cameraHoverHeight) {
							camera.position.y -= (intersects[0].distance-cameraHoverHeight)/2;
						}
						if (intersects[0].distance < cameraHoverHeight) {
							camera.position.y += (cameraHoverHeight-intersects[0].distance)/2;
						}
					}
	
					var jhStats = document.getElementById("jhStats");
					jhStats.innerHTML = "(X,Z,Y): " + Math.round(camera.position.x) + "," + Math.round(camera.position.z) + "," + Math.round(camera.position.y) + "<br>";// +
											//	"CamHovHeight: " + intersects[0].distance;
					
	
					controls.update( delta );
					renderer.render( scene, camera );
	
				}
				
				function densifyWorld(inGeom) {
					// create a new geometry that's twice as dense as the input
					// set the xyz of existing vertices
					// set the xyz of new vertices
						// when spacing is at minimum, y is half of deltaY of adjacent vertices (0% new Y)
						// when spacing is at maximum, y is eroded height
					return outGeom;
				}
	
				function shiftAlongAxis(axis) {
					controls.freeze = true;
					var deltaCamera;
					if (axis.toUpperCase()=='X') {
						deltaCamera = camera.position.x;
						for (var i = 0, l = geometry.vertices.length; i < l; i++ ) {
							geometry.vertices[i].x = geometry.vertices[i].x - deltaCamera;
						}
						camera.position.x = 0;
					} else {
						deltaCamera = camera.position.z;
						for (var i = 0, l = geometry.vertices.length; i < l; i++ ) {
							geometry.vertices[i].z = geometry.vertices[i].z - deltaCamera;
						}
						camera.position.z = 0;
					}
					controls.freeze = false;
					mesh.geometry.verticesNeedUpdate = true;
				}
	
				function growLandscape() {
					// increase distance of each vertex from origin by a small factor
					
					var growFactor = 1.001;
					
					// var eVector = new THREE.Vector3(0,-1,0);
					// var eRayCaster = new THREE.Raycaster(camera.position, eVector);
					// var intersects = eRayCaster.intersectObject(mesh);
					// var yCorrect = (geometry.vertices[geometry.vertices.length/2].y * 0.01) + (intersects.length * 0.01);
					
					for ( var i = 0, l = geometry.vertices.length; i < l; i ++ ) {
						geometry.vertices[i].x *= growFactor;
						geometry.vertices[i].z *= growFactor;
						geometry.vertices[i].y = (geometry.vertices[i].y * growFactor);
						//geometry.verticesNeedUpdate = true;
						mesh.geometry.verticesNeedUpdate = true;
					}
					
				}
				
				function resetPosition() {
					// freeze the controls
					controls.freeze = true;
					
					// capture the current X and Z diffs
					var currXdiff = camera.position.x;
					var currZdiff = camera.position.z;
					
					// apply diffs to each vertex
					for ( var i = 0, l = geometry.vertices.length; i < l; i ++ ) {
						geometry.vertices[i].x -= currXdiff;
						geometry.vertices[i].z -= currZdiff;
						//geometry.verticesNeedUpdate = true;
						mesh.geometry.verticesNeedUpdate = true;
					}
					
					// reposition the camera at 0,0
					camera.position.x = 0;
					camera.position.z = 0;
					
					// unfreeze the controls
					controls.freeze = false;
				}
				
				function calcRawIter(worldX, worldZ) {
					var cX = (worldX + (fcX * scaleFactor * mag)) / (scaleFactor * mag); 
					var cY = (worldZ + (fcY * scaleFactor * mag)) / (scaleFactor * mag);
					var arrCalc = fracUtils.getIter(cX, cY, 10, maxIter);
					var returnVal = arrCalc[0];
					return returnVal;
				}
	
				function calcRawIter2(cX, cY) {
					var arrCalc = fracUtils.getIter(cX, cY, 10, maxIter);
					var returnVal = arrCalc[0];
					return returnVal;
				}
				

				
				function erodeLandscape() {
						// erode the landscape
						var erosion = [];
						var iTarget; // verext to which erosion will flow
						var iN, iW, iE, iS;
						var hnN, hnW, hnE, hnS; 
						//alert("Original height of i = " + geometry.vertices[testi].y);
						for ( i = 0, l = geometry.vertices.length; i < l; i ++ ) {
							iN = fracUtils.getNeighborIndex(i, worldWidth, "N");
							iW = fracUtils.getNeighborIndex(i, worldWidth, "W");
							iE = fracUtils.getNeighborIndex(i, worldWidth, "E");
							iS = fracUtils.getNeighborIndex(i, worldWidth, "S");
							if (iN!=null) {hnN = geometry.vertices[iN].y;} else {hnN=null;}
							if (iW!=null) {hnW = geometry.vertices[iW].y;} else {hnW=null;}
							if (iE!=null) {hnE = geometry.vertices[iE].y;} else {hnE=null;}
							if (iS!=null) {hnS = geometry.vertices[iS].y;} else {hnS=null;}
							erosion = fracUtils.erodeHeight(i, geometry.vertices[i].y, hnN, hnW, hnE, hnS, worldWidth); 
							geometry.vertices[i].y = erosion[0];
							iTarget = erosion[1];
							geometry.vertices[iTarget].y += erosion[2];
						}
						//alert("New height of vertex[" + testi + "] = " + geometry.vertices[testi].y);
	
					}
	
				function onWindowResize() {
	
					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();
	
					renderer.setSize( window.innerWidth, window.innerHeight );
	
					controls.handleResize();
	
				}
	
				function animate() {
	
					requestAnimationFrame( animate );
	
					render();
					//stats.update();
	
				}
			});
		</script>

	</body>
</html>
